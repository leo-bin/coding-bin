{"./":{"url":"./","title":"首页","keywords":"","body":"bin的个人文档库 这是斌的个人文档库，欢迎一起交流！ 一 占位 这里有东西。。。 这里也有东西。。。 这里也有东西。。。 二 占位 这里也有东西。。。 这里也有东西。。。 这里也有东西。。。 二 假装有东西 这是斌的个人文档库，欢迎一起交流！ Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 21:41:42 "},"算法/":{"url":"算法/","title":"我的算法爬坑之路","keywords":"","body":"我的算法爬坑之路 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/":{"url":"算法/数据结构/","title":"数据结构","keywords":"","body":"数据结构 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/数组.html":{"url":"算法/数据结构/数组.html","title":"数组","keywords":"","body":"数组 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/链表.html":{"url":"算法/数据结构/链表.html","title":"链表","keywords":"","body":"链表 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/哈希表.html":{"url":"算法/数据结构/哈希表.html","title":"哈希表","keywords":"","body":"哈希表 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/树.html":{"url":"算法/数据结构/树.html","title":"树","keywords":"","body":"树 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/数据结构/队列.html":{"url":"算法/数据结构/队列.html","title":"队列","keywords":"","body":"队列 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/":{"url":"算法/排序/","title":"排序算法","keywords":"","body":"排序算法 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/选择.html":{"url":"算法/排序/选择.html","title":"选择排序","keywords":"","body":"选择排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/冒泡.html":{"url":"算法/排序/冒泡.html","title":"冒泡排序","keywords":"","body":"冒泡排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/插入.html":{"url":"算法/排序/插入.html","title":"插入排序","keywords":"","body":"插入排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/快排.html":{"url":"算法/排序/快排.html","title":"快速排序","keywords":"","body":"快速排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/归并.html":{"url":"算法/排序/归并.html","title":"归并排序","keywords":"","body":"归并排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/排序/堆排序.html":{"url":"算法/排序/堆排序.html","title":"堆排序","keywords":"","body":"堆排序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/搜索.html":{"url":"算法/搜索.html","title":"搜索算法","keywords":"","body":"搜索算法 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/lru.html":{"url":"算法/lru.html","title":"LRU算法","keywords":"","body":"什么是LRU？ 1.Latest Recently Unuesd（最近最少未使用）。 2.如果一个数据在最近一段时间内都没有被访问，那么就认为这个数据在以后被访问的概率也很小了。 3.所以当内存满了的时候，这个数据就会最先被淘汰掉。 如何实现？ 1.最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。 2.因此，我们可以用双向链表+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找）。 3或者也可以利用Java中现成的数据结构LinkedHashMap来实现一个简单的LRU算法。 一 使用现有的数据结构实现 package com.bins.algorithm.lru; import java.util.LinkedHashMap; import java.util.Map; /** * @author leo-bin * @date 2020/2/23 19:50 * @apiNote 使用LinkedHashMap实现 */ public class LRUCache extends LinkedHashMap { /** * 初始缓存大小 */ private final int CACHE_SIZE; /** * 初始化缓存，并设置大小 * * @param cacheSize 缓存大小 */ public LRUCache(int cacheSize) { //初始化一个LinkedHashMap，true表示按照访问顺序来进行排序，最近访问的数据放在尾部，最老访问的放在头部 super((int) Math.ceil((cacheSize / 0.75) + 1), 0.75f, true); this.CACHE_SIZE = cacheSize; } /** * 是否移除最久没被访问的那个节点 * * @return 是否满足删除条件 */ @Override protected boolean removeEldestEntry(Map.Entry eldest) { //判断现在map中的数量是否达到了指定的缓存数 //在调用put方法的时候，会调用这个方法，如果达到了缓存的大小，删掉最长时间没被访问的entry return size() > CACHE_SIZE; } } 测试结果 package com.bins.algorithm.lru; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * @author leo-bin * @date 2020/2/23 21:04 * @apiNote LRU测试 */ public class LRUTest { private static final Logger log = LoggerFactory.getLogger(LRUTest.class); /** * 初始化一个容量大小为10的LRU缓存 */ private static LRUCache lruCache = new LRUCache<>(10); public static void main(String[] args) { //往缓存中加10个数，加入之后，缓存现在已经满了 for (int i = 0; i 二 使用HashMap+双向链表实现 1.我们可以利用双向链表的特点，分别设置一个头指针和尾指针，从而方便的进行双向遍历。 2.要想实现put和get操作都是O(1)的时间复杂度我们使用HashMap来存储我们的双向链表的节点。 3.put操作需要做两件事情，一是检查缓存空间是否达到预期阈值，如果没满，直接存map然后修改双向链表的指向。 4.二是如果要put的元素已经存在过了，那么这次put就相当于update，我们需要更新下该元素的访问频率。 5.访问频率本质上就是先在双向链表中将该元素删掉，然后重新添加到链表尾部。 6.如果put的时候达到了阈值，那就需要做淘汰，根据LRU的特性应该将最近最少使用过的元素淘汰掉，我们直接将链表头的元素删掉然后重新调正双向链表就行。 代码如下： package com.bins.algorithm.lru; import java.util.HashMap; /** * @author leo-bin * @date 2020/4/7 19:44 * @apiNote 使用HashMap+双链表+synchronized实现(线程安全) */ public class LRUCacheV2 { /** * 缓存容量 */ private final int cacheSize; private HashMap map; private Node head; private Node tail; public LRUCacheV2(int cacheSize) { this.cacheSize = cacheSize; this.map = new HashMap<>(16); } /** * 内部节点类 */ public class Node { private String key; private volatile String value; private Node pre; private Node next; public Node(String key, String value) { this.key = key; this.value = value; } } /** * get操作 * 时间复杂度：O(1) */ public String get(String key) { Node node = map.get(key); if (node == null) { return null; } else { refreshNode(node); return node.value; } } /** * put操作 * 时间复杂度：O(1) */ public void put(String key, String value) { Node node = map.get(key); synchronized (this) { if (node == null) { //缓存已满，需要删除最近最少使用的节点，其实就是头结点 if (map.size() >= cacheSize) { Node oldNode = removeNode(head); map.remove(oldNode.key); } //没满或者删掉之后，放map中 node = new Node(key, value); map.put(key, node); addNode(node); } //node已经存在，修改访问频率，并修改map中的value else { node.value = value; map.put(key, node); refreshNode(node); } } } /** * 刷新当前的链表 */ private void refreshNode(Node node) { if (node == tail) { return; } if (node != null) { removeNode(node); addNode(node); } } /** * 往链表尾部增加一个节点 */ private void addNode(Node node) { //1.head为空，那就将head指向node if (head == null) { head = node; } //2.tail不为空说明链表中有元素了，改变指向 if (tail != null) { tail.next = node; node.pre = tail; node.next = null; } //3.tail无论如何都要先指向node tail = node; } /** * 随机删除链表中的一个节点 */ private Node removeNode(Node node) { //鲁棒 if (node == null) { return node; } //1.要删除的节点是唯一节点 if (node == head && node == tail) { head = null; tail = null; } //2.要删除的节点是head节点 else if (node == head) { head = node.next; node.next.pre = null; node.next = null; } //3.要删除的节点是tail节点 else if (node == tail) { tail = node.pre; node.pre.next = null; node.pre = null; } //4.要删除的节点是中间节点 else { node.pre.next = node.next; node.next.pre = node.pre; node.next = null; node.pre = null; } return node; } 测试结果 public static void main(String[] args) { LRUCacheV2 lruCache = new LRUCacheV2(4); //初始化缓存，加四个元素进去 lruCache.put(\"1\", \"User1\"); lruCache.put(\"2\", \"User2\"); lruCache.put(\"3\", \"User3\"); lruCache.put(\"4\", \"User4\"); //get一下其中一个元素User1 System.out.println(lruCache.get(\"1\")); //再加一个元素，加入之后User2应该被删掉了 lruCache.put(\"5\", \"User5\"); //验证下User2是否被删掉了 System.out.println(\"User2=\" + lruCache.get(\"2\")); } 总结 这里写测试结论和小结。。。 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-02 21:06:55 "},"算法/id生成.html":{"url":"算法/id生成.html","title":"id生成算法","keywords":"","body":"id生成算法 如何生成全局唯一id 如何生成全局唯一id 参考代码 package com.bins.algorithm.idgenerator; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @author leo-bin * @date 2020/4/24 10:08 * @apiNote 全局唯一id生成器，雪花算法 */ public class SnowFlake { /** * 初始时间截 (2017-01-01) */ private static final long INITIAL_TIME_STAMP = 1483200000000L; /** * 机器id所占的位数 */ private static final long WORKER_ID_BITS = 5L; /** * 数据标识id所占的位数 */ private static final long DATACENTER_ID_BITS = 5L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private static final long MAX_WORKER_ID = ~(-1L MAX_WORKER_ID || workerId MAX_DATACENTER_ID || dataCenterId 测试代码 /** * note: * SnowFlake所生成的ID一共分成四部分 * 1.第一位 * 占用1bit，其值始终是0，没有实际作用 * 2.时间戳 * 占用41bit，精确到毫秒，总共可以容纳约140年的时间 * 3.工作机器id * 占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），最多可以容纳1024个节点 * 4.序列号 * 占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095 * * SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法 * 同一毫秒的ID数量 = 1024 X 4096 = 4194304 * 这个数字在绝大多数并发场景下都是够用的 */ public static void main(String[] args) { final SnowFlake idGenerator = new SnowFlake(1, 1); // 线程池并行执行10000次ID生成 ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i 测试结果 总结 本次介绍了id生成算法雪花算法还有其他的全局唯一id生成方法 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-02 21:15:21 "},"算法/pv.html":{"url":"算法/pv.html","title":"生产者消费者","keywords":"","body":"生产者消费者 本次给大家介绍下如何使用Java写一个简易的生产者消费者模板 生产者-消费者 参考代码 package com.bins.algorithm.pv; import java.util.LinkedList; /** * @author leo-bin * @date 2020/4/24 17:22 * @apiNote 生产者消费者，synchronized+LinkedList实现 */ public class ProducerAndConsumerV1 { /** * 未满锁 */ private final Object notFullLock = new Object(); /** * 非空锁 */ private final Object notNullLock = new Object(); /** * 容量 */ private int capacity; /** * 数据容器 */ private LinkedList container; public ProducerAndConsumerV1() { this.container = new LinkedList<>(); } /** * 消费数据 */ public T get() { //1.如果是空的话，当前消费者线程阻塞 while (container.size() == 0) { synchronized (notNullLock) { try { notNullLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //2.不为空，取数据 T data = container.poll(); --capacity; //3.唤醒正在阻塞的生产者线程 synchronized (notFullLock) { notFullLock.notify(); } return data; } /** * 生产数据 */ public boolean set(T value) { //1.满了，当前的生产者线程阻塞 while (container.size() == capacity) { synchronized (notFullLock) { try { notFullLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //2.没满，放数据 boolean result = container.add(value); ++capacity; //3.唤醒正在阻塞的消费者线程 synchronized (notNullLock) { notNullLock.notify(); } return result; } 测试代码 public static void main(String[] args) { //设置初始容量为10 int cap = 10; ProducerAndConsumerV1 pv = new ProducerAndConsumerV1<>(cap); //开一个生产者线程 new Thread(() -> { System.out.println(Thread.currentThread().getName() + \"尝试获取\"); System.out.println(Thread.currentThread().getName() + \"获取了一个元素：\" + pv.get()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"设置了一个元素，状态：\" + pv.set(\"test1\")); }).start(); //开一个消费者线程 new Thread(() -> { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"设置了一个元素，状态：\" + pv.set(\"test2\")); System.out.println(Thread.currentThread().getName() + \"尝试获取\"); System.out.println(Thread.currentThread().getName() + \"获取了一个元素：\" + pv.get()); }).start(); } 测试结果 总结 本次给大家介绍了生产者消费者模板 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-02 21:26:54 "},"算法/String匹配.html":{"url":"算法/String匹配.html","title":"字符串匹配算法","keywords":"","body":"字符串匹配算法 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/skiplist.html":{"url":"算法/skiplist.html","title":"跳跃表","keywords":"","body":"跳跃表 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"算法/面试算法.html":{"url":"算法/面试算法.html","title":"面试常考算法场景","keywords":"","body":"面试常考算法场景 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"刷题/":{"url":"刷题/","title":"刷题","keywords":"","body":"刷题 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"刷题/衣.html":{"url":"刷题/衣.html","title":"第1节：衣","keywords":"","body":"第1节：衣 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"计算机基础/":{"url":"计算机基础/","title":"计算机基础","keywords":"","body":"计算机基础 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"计算机基础/计网.html":{"url":"计算机基础/计网.html","title":"计算机网络","keywords":"","body":"计算机网络 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"计算机基础/操作系统.html":{"url":"计算机基础/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/":{"url":"Java/","title":"Java","keywords":"","body":"Java Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/jvm.html":{"url":"Java/jvm.html","title":"JVM","keywords":"","body":"JVM Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/java基础.html":{"url":"Java/java基础.html","title":"Java基础","keywords":"","body":"Java基础 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/集合.html":{"url":"Java/集合.html","title":"集合","keywords":"","body":"集合 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/线程和并发.html":{"url":"Java/线程和并发.html","title":"多线程和并发","keywords":"","body":"多线程和并发 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"Java/javaweb.html":{"url":"Java/javaweb.html","title":"JavaWeb","keywords":"","body":"JavaWeb Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"设计模式/":{"url":"设计模式/","title":"设计模式","keywords":"","body":"设计模式 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"设计模式/单例.html":{"url":"设计模式/单例.html","title":"单例模式","keywords":"","body":"单例模式 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"设计模式/代理.html":{"url":"设计模式/代理.html","title":"代理模式","keywords":"","body":"代理模式 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"设计模式/工厂.html":{"url":"设计模式/工厂.html","title":"工厂模式","keywords":"","body":"工厂模式 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"设计模式/策略.html":{"url":"设计模式/策略.html","title":"策略模式","keywords":"","body":"策略模式 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"数据库/":{"url":"数据库/","title":"数据库","keywords":"","body":"数据库 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"数据库/mysql.html":{"url":"数据库/mysql.html","title":"MySQL","keywords":"","body":"MySQL Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"数据库/redis.html":{"url":"数据库/redis.html","title":"Redis","keywords":"","body":"Redis Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"数据库/mongodb.html":{"url":"数据库/mongodb.html","title":"MongoDB","keywords":"","body":"MongoDB Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"数据库/es.html":{"url":"数据库/es.html","title":"Elasticsearch","keywords":"","body":"Elasticsearch Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"中间件/":{"url":"中间件/","title":"中间件","keywords":"","body":"中间件 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"中间件/rabbitmq.html":{"url":"中间件/rabbitmq.html","title":"RabbitMQ","keywords":"","body":"RabbitMQ Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"中间件/kafaka.html":{"url":"中间件/kafaka.html","title":"Kafaka","keywords":"","body":"Kafaka Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"中间件/rocketmq.html":{"url":"中间件/rocketmq.html","title":"RocketMQ","keywords":"","body":"RocketMQ Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"中间件/mycat.html":{"url":"中间件/mycat.html","title":"MyCat","keywords":"","body":"MyCat Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/":{"url":"框架/","title":"框架","keywords":"","body":"框架 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/spring.html":{"url":"框架/spring.html","title":"Spring","keywords":"","body":"Spring Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/mybatis.html":{"url":"框架/mybatis.html","title":"MyBatis","keywords":"","body":"MyBatis Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/disruptor.html":{"url":"框架/disruptor.html","title":"Disruptor","keywords":"","body":"Disruptor Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/jwt.html":{"url":"框架/jwt.html","title":"JWT","keywords":"","body":"JWT Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/shiro.html":{"url":"框架/shiro.html","title":"Shiro","keywords":"","body":"Shiro Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"框架/graylog.html":{"url":"框架/graylog.html","title":"Graylog","keywords":"","body":"Graylog Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/":{"url":"大数据/","title":"大数据","keywords":"","body":"大数据 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/hadoop.html":{"url":"大数据/hadoop.html","title":"Hadoop","keywords":"","body":"Hadoop Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/hdfs.html":{"url":"大数据/hdfs.html","title":"HDFS","keywords":"","body":"HDFS Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/mr.html":{"url":"大数据/mr.html","title":"Mapreduce","keywords":"","body":"Mapreduce Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/hbase.html":{"url":"大数据/hbase.html","title":"Hbase","keywords":"","body":"Hbase Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/sqoop.html":{"url":"大数据/sqoop.html","title":"Sqoop","keywords":"","body":"Sqoop Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/hive.html":{"url":"大数据/hive.html","title":"Hive","keywords":"","body":"Hive Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/scala.html":{"url":"大数据/scala.html","title":"Scala","keywords":"","body":"Scala Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/spark.html":{"url":"大数据/spark.html","title":"Spark","keywords":"","body":"Spark Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大数据/zookeeper.html":{"url":"大数据/zookeeper.html","title":"ZooKeeper","keywords":"","body":"ZooKeeper Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"devops/":{"url":"devops/","title":"自动化","keywords":"","body":"自动化 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"devops/docker.html":{"url":"devops/docker.html","title":"Docker","keywords":"","body":"Docker Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"devops/k8s.html":{"url":"devops/k8s.html","title":"K8s","keywords":"","body":"K8s Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"devops/jenkins.html":{"url":"devops/jenkins.html","title":"Jenkins","keywords":"","body":"Jenkins Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大前端/":{"url":"大前端/","title":"大前端","keywords":"","body":"大前端 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大前端/基础.html":{"url":"大前端/基础.html","title":"HTML+CSS+JS","keywords":"","body":"HTML+CSS+JS Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大前端/小程序.html":{"url":"大前端/小程序.html","title":"微信小程序","keywords":"","body":"微信小程序 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"大前端/vue.html":{"url":"大前端/vue.html","title":"Vue","keywords":"","body":"Vue Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"机器学习AI/":{"url":"机器学习AI/","title":"机器学习+人工智能","keywords":"","body":"机器学习+人工智能 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"机器学习AI/衣.html":{"url":"机器学习AI/衣.html","title":"第1节","keywords":"","body":"第1节 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"生活随笔/":{"url":"生活随笔/","title":"生活随笔","keywords":"","body":"生活随笔 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "},"生活随笔/衣.html":{"url":"生活随笔/衣.html","title":"第1节","keywords":"","body":"第1节 Copyright © leo-bin all right reserved，powered by Gitbook该文件修订时间： 2020-05-01 22:33:20 "}}